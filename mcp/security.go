package mcp

import (
	"context"
	"errors"
	"fmt"
	"strings"

	"github.com/xeipuuv/gojsonschema"
)

// Role defines the originator of a message in the conversation history.
type Role string

const (
	RoleSystem    Role = "system" // Instructions or context provided by the system/developer
	RoleUser      Role = "user"
	RoleAssistant Role = "assistant" // Messages generated by the LLM
	RoleTool      Role = "tool"      // Results returned from tool execution
)

// --- Security & Metadata Structures ---

// SecurityMetadata contains information used to verify the trust and integrity of components.
type SecurityMetadata struct {
	Source      string `json:"source,omitempty"`        // Origin of the data (e.g., "trusted-registry", "user-provided", "api-endpoint-v2")
	Signature   string `json:"signature,omitempty"`     // Cryptographic signature to verify authenticity/integrity (e.g., JWT, HMAC-SHA256)
	PublicKeyID string `json:"public_key_id,omitempty"` // Identifier for the key needed to verify the signature
	Version     string `json:"version,omitempty"`       // Version identifier for the tool description or other signed component
	Checksum    string `json:"checksum,omitempty"`      // Hash of the component itself (e.g., hash of the ToolDescription structure)
}

// ContextMetadata holds general metadata for the context snapshot.
type ContextMetadata struct {
	ClientID       string            `json:"client_id,omitempty"`       // Identifier for the end-user or client application
	SessionID      string            `json:"session_id,omitempty"`      // Identifier for the user's session
	TraceID        string            `json:"trace_id,omitempty"`        // Identifier for tracing requests across systems
	RequestingUser *UserIdentity     `json:"requesting_user,omitempty"` // Information about the user initiating the request
	CustomData     map[string]string `json:"custom_data,omitempty"`     // For application-specific metadata
}

// UserIdentity represents information about the end user.
type UserIdentity struct {
	UserID string         `json:"user_id"`
	Groups []string       `json:"groups,omitempty"`
	Claims map[string]any `json:"claims,omitempty"` // e.g., JWT claims
}

// SecurityPolicy defines rules and constraints for the interaction.
type SecurityPolicy struct {
	AllowedTools        []string `json:"allowed_tools,omitempty"`           // Explicit list of tools allowed (whitelist)
	DisallowedTools     []string `json:"disallowed_tools,omitempty"`        // Explicit list of tools disallowed (blacklist)
	RequiredToolSource  string   `json:"required_tool_source,omitempty"`    // Tools must originate from this source (e.g., "trusted-registry")
	MaxToolCallsPerTurn int      `json:"max_tool_calls_per_turn,omitempty"` // Limit on tool calls per assistant turn
	DataHandlingRules   string   `json:"data_handling_rules,omitempty"`     // Instructions or policy references for data privacy/handling
}

// --- Tool Schema Validation ---

// FindToolDescription retrieves the trusted tool description by name.
// In a real system, this might involve looking up in a secure registry
// and potentially verifying signatures/sources stored in SecurityMetadata.
func FindToolDescription(name string, availableTools []ToolDescription) (*ToolDescription, error) {
	for _, tool := range availableTools {
		if tool.Name == name {
			// TODO: Add verification of tool description source/integrity here
			// based on tool.SecurityMetadata if available.
			return &tool, nil // Return pointer to avoid copying large schemas
		}
	}
	return nil, fmt.Errorf("tool '%s' not found or not permitted", name)
}

// ValidateToolSchema is called by the orchestrator when an LLM requests a tool call.
func ValidateToolSchema(
	ctx context.Context,
	toolCall ToolCall,
	availableTools []ToolDescription,
) (executionStatus ExecutionStatus, execErr error) {
	toolDesc, err := FindToolDescription(toolCall.FunctionName, availableTools)
	if err != nil {
		return StatusError, fmt.Errorf("tool description lookup failed: %w", err)
	}

	// Only validate if schema is provided
	if len(toolDesc.InputSchema) > 0 {
		schemaLoader := gojsonschema.NewBytesLoader(toolDesc.InputSchema)
		documentLoader := gojsonschema.NewBytesLoader(toolCall.Arguments)
		schema, err := gojsonschema.NewSchema(schemaLoader)
		if err != nil {
			return StatusError, fmt.Errorf("internal schema error for tool '%s'", toolDesc.Name)
		}

		result, err := schema.Validate(documentLoader)
		if err != nil {
			return StatusError, fmt.Errorf("internal validation error for tool '%s'", toolDesc.Name)
		}

		if !result.Valid() {
			var validationErrors []string
			for _, desc := range result.Errors() {
				validationErrors = append(validationErrors, fmt.Sprintf("- %s", desc))
			}
			errorMsg := fmt.Sprintf("Input validation failed for tool '%s':\n%s",
				toolDesc.Name, strings.Join(validationErrors, "\n"))
			fmt.Println("SECURITY ALERT:", errorMsg)
			return StatusFailed, errors.New(errorMsg)
		}
		fmt.Printf("Input arguments for tool '%s' validated successfully.\n", toolDesc.Name)
	} else {
		return StatusFailed, fmt.Errorf("no InputSchema defined for tool '%s'", toolDesc.Name)
	}

	return StatusSucceeded, nil
}

func ValidateToolCallOutput(
	rawResult string,
	toolCall ToolCall,
	availableTools []ToolDescription,
) (ExecutionStatus, error) {
	toolDesc, err := FindToolDescription(toolCall.FunctionName, availableTools)
	if err != nil {
		return StatusError, fmt.Errorf("tool description lookup failed: %w", err)
	}

	if len(toolDesc.OutputSchema) > 0 {
		outputSchemaLoader := gojsonschema.NewBytesLoader(toolDesc.OutputSchema)
		outputDocumentLoader := gojsonschema.NewStringLoader(rawResult)

		outputSchema, err := gojsonschema.NewSchema(outputSchemaLoader)
		if err != nil {
			fmt.Printf("ERROR: Invalid OutputSchema for tool '%s': %v\n", toolDesc.Name, err)
			return StatusError, fmt.Errorf("internal output schema error for tool '%s'", toolDesc.Name)
		}

		outputResult, err := outputSchema.Validate(outputDocumentLoader)
		if err != nil {
			fmt.Printf("ERROR: Output validation process error for tool '%s': %v\n", toolDesc.Name, err)
			return StatusError, fmt.Errorf("internal output validation error for tool '%s'", toolDesc.Name)
		}

		if !outputResult.Valid() {
			var validationErrors []string
			for _, desc := range outputResult.Errors() {
				validationErrors = append(validationErrors, fmt.Sprintf("- %s", desc))
			}
			errorMsg := fmt.Sprintf("Tool '%s' output failed validation:\n%s\nRaw Output: %s",
				toolDesc.Name, strings.Join(validationErrors, "\n"), rawResult)
			fmt.Println("SECURITY ALERT:", errorMsg)
			return StatusFailed, errors.New(errorMsg)
		}
		fmt.Printf("Output content for tool '%s' validated successfully.\n", toolDesc.Name)
	}
	return StatusSucceeded, nil
}
