package mcp

import (
	"crypto/sha256"
	"encoding/hex"
	"encoding/json"
	"errors"
	"fmt"
	"sort"
)

// Role defines the originator of a message in the conversation history.
type Role string

const (
	RoleSystem    Role = "system" // Instructions or context provided by the system/developer
	RoleUser      Role = "user"
	RoleAssistant Role = "assistant" // Messages generated by the LLM
	RoleTool      Role = "tool"      // Results returned from tool execution
)

// --- Security & Metadata Structures ---

// SecurityMetadata contains information used to verify the trust and integrity of components.
type SecurityMetadata struct {
	Source        string `json:"source,omitempty"`         // Origin of the data (e.g., "trusted-registry", "user-provided", "api-endpoint-v2")
	Signature     string `json:"signature,omitempty"`      // Cryptographic signature to verify authenticity/integrity (e.g., JWT, HMAC-SHA256)
	PublicKeyID   string `json:"public_key_id,omitempty"`  // Identifier for the key needed to verify the signature
	Version       string `json:"version,omitempty"`        // Version identifier for the tool description or other signed component
	IntegrityHash string `json:"integrity_hash,omitempty"` // Hash of the component itself (e.g., hash of the ToolDescription structure)
}

// ContextMetadata holds general metadata for the context snapshot.
type ContextMetadata struct {
	ClientID       string            `json:"client_id,omitempty"`       // Identifier for the end-user or client application
	SessionID      string            `json:"session_id,omitempty"`      // Identifier for the user's session
	TraceID        string            `json:"trace_id,omitempty"`        // Identifier for tracing requests across systems
	RequestingUser *UserIdentity     `json:"requesting_user,omitempty"` // Information about the user initiating the request
	CustomData     map[string]string `json:"custom_data,omitempty"`     // For application-specific metadata
}

// UserIdentity represents information about the end user.
type UserIdentity struct {
	UserID string         `json:"user_id"`
	Groups []string       `json:"groups,omitempty"`
	Claims map[string]any `json:"claims,omitempty"` // e.g., JWT claims
}

// SecurityPolicy defines rules and constraints for the interaction.
type SecurityPolicy struct {
	AllowedTools        []string `json:"allowed_tools,omitempty"`           // Explicit list of tools allowed (whitelist)
	DisallowedTools     []string `json:"disallowed_tools,omitempty"`        // Explicit list of tools disallowed (blacklist)
	RequiredToolSource  string   `json:"required_tool_source,omitempty"`    // Tools must originate from this source (e.g., "trusted-registry")
	MaxToolCallsPerTurn int      `json:"max_tool_calls_per_turn,omitempty"` // Limit on tool calls per assistant turn
	DataHandlingRules   string   `json:"data_handling_rules,omitempty"`     // Instructions or policy references for data privacy/handling
}

// ToolRegistry maintains the set of trusted tools and schemas
type ToolRegistry struct {
	tools               map[string]Tool
	securityEnabled     bool
	validateChecksums   bool
	rejectUnsignedTools bool
}

// NewToolRegistry creates a new tool registry
func NewToolRegistry(securityEnabled bool) *ToolRegistry {
	return &ToolRegistry{
		tools:           make(map[string]Tool),
		securityEnabled: securityEnabled,
	}
}

// SetSecurityOptions configures the security options for the tool registry
func (tr *ToolRegistry) SetSecurityOptions(validateChecksums, rejectUnsignedTools bool) {
	tr.validateChecksums = validateChecksums
	tr.rejectUnsignedTools = rejectUnsignedTools
}

// RegisterTool adds a tool to the registry with security checks
func (tr *ToolRegistry) RegisterTool(tool Tool) error {
	if tr.securityEnabled {
		// Generate the checksum and fingerprint if not already present
		if tool.Checksum == "" {
			checksum, err := generateToolChecksum(tool)
			if err != nil {
				return err
			}
			tool.Checksum = checksum
		}

		if tool.Fingerprint == "" {
			fingerprint, err := generateSchemaFingerprint(tool.Schema)
			if err != nil {
				return err
			}
			tool.Fingerprint = fingerprint
		}
	}

	tr.tools[tool.Name] = tool
	return nil
}

// GetTool retrieves a tool from the registry with security validation
func (tr *ToolRegistry) GetTool(name string) (Tool, error) {
	tool, exists := tr.tools[name]
	if !exists {
		return Tool{}, fmt.Errorf("tool '%s' not found", name)
	}

	if tr.securityEnabled && tr.validateChecksums {
		expectedChecksum, err := generateToolChecksum(tool)
		if err != nil {
			return Tool{}, err
		}

		if expectedChecksum != tool.Checksum {
			return Tool{}, errors.New("tool checksum validation failed")
		}

		expectedFingerprint, err := generateSchemaFingerprint(tool.Schema)
		if err != nil {
			return Tool{}, err
		}

		if expectedFingerprint != tool.Fingerprint {
			return Tool{}, errors.New("schema fingerprint validation failed")
		}
	}

	if tr.securityEnabled && tr.rejectUnsignedTools && (tool.Checksum == "" || tool.Fingerprint == "") {
		return Tool{}, errors.New("unsigned tool rejected")
	}

	return tool, nil
}

// ListTools returns all registered tools
func (tr *ToolRegistry) ListTools() ToolSet {
	tools := make([]Tool, 0, len(tr.tools))
	for _, tool := range tr.tools {
		tools = append(tools, tool)
	}

	// Sort tools by name for consistent ordering
	sort.Slice(tools, func(i, j int) bool {
		return tools[i].Name < tools[j].Name
	})

	return ToolSet{
		Tools:                 tools,
		SecurityEnabled:       tr.securityEnabled,
		SchemaFingerprintAlgo: "SHA-256",
		ChecksumAlgo:          "SHA-256",
	}
}

// canonicalizeJson converts a JSON object to a canonical form for consistent hashing
func canonicalizeJson(data json.RawMessage) (json.RawMessage, error) {
	var obj interface{}
	if err := json.Unmarshal(data, &obj); err != nil {
		return nil, err
	}

	// Sort keys and ensure consistent serialization
	canonical, err := json.Marshal(obj)
	if err != nil {
		return nil, err
	}

	return canonical, nil
}

// generateSchemaFingerprint creates a fingerprint of the schema using SHA-256
func generateSchemaFingerprint(schema json.RawMessage) (string, error) {
	canonical, err := canonicalizeJson(schema)
	if err != nil {
		return "", err
	}

	hash := sha256.Sum256(canonical)
	return hex.EncodeToString(hash[:]), nil
}

// generateToolChecksum creates a checksum of the entire tool definition using SHA-256
func generateToolChecksum(tool Tool) (string, error) {
	// Create a copy without the checksum field
	toolCopy := Tool{
		Name:        tool.Name,
		Description: tool.Description,
		Schema:      tool.Schema,
		Fingerprint: tool.Fingerprint,
	}

	// Serialize to JSON
	data, err := json.Marshal(toolCopy)
	if err != nil {
		return "", err
	}

	// Use canonical JSON for consistent checksums
	canonical, err := canonicalizeJson(data)
	if err != nil {
		return "", err
	}

	hash := sha256.Sum256(canonical)
	return hex.EncodeToString(hash[:]), nil
}

// ToolVerificationError represents an error during tool verification
type ToolVerificationError struct {
	Message string
	Code    int
}

// Error returns the error message
func (e ToolVerificationError) Error() string {
	return e.Message
}

// ErrorCode constants for tool verification
const (
	ErrChecksumMismatch      = 4001
	ErrFingerprintMismatch   = 4002
	ErrUnsignedTool          = 4003
	ErrToolNotFound          = 4004
	ErrInvalidToolDefinition = 4005
)
