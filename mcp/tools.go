package mcp

import (
	"encoding/json"
	"time"
)

// ToolOption is a function that configures a Tool.
// It provides a flexible way to set various properties of a Tool using the functional options pattern.
type ToolOption func(*ToolDefinition)

type ToolInputSchema struct {
	Type       string                 `json:"type"`
	Properties map[string]interface{} `json:"properties,omitempty"`
	Required   []string               `json:"required,omitempty"`
}

// Tool represents a tool definition in MCP
type Tool struct {
	Name        string          `json:"name"`
	Description string          `json:"description"`
	Schema      json.RawMessage `json:"schema"`
	Fingerprint string          `json:"fingerprint,omitempty"` // Schema fingerprint
	Checksum    string          `json:"checksum,omitempty"`    // Tool definition checksum
}

// ToolSet represents a collection of tools with security information
type ToolSet struct {
	Tools                 []Tool `json:"tools"`
	SecurityEnabled       bool   `json:"securityEnabled"`
	SchemaFingerprintAlgo string `json:"schemaFingerprintAlgo,omitempty"`
	ChecksumAlgo          string `json:"checksumAlgo,omitempty"`
}

type ToolAnnotation struct {
	// Human-readable title for the tool
	Title string `json:"title,omitempty"`
	// If true, the tool does not modify its environment
	ReadOnlyHint bool `json:"readOnlyHint,omitempty"`
	// If true, the tool may perform destructive updates
	DestructiveHint bool `json:"destructiveHint,omitempty"`
	// If true, repeated calls with same args have no additional effect
	IdempotentHint bool `json:"idempotentHint,omitempty"`
	// If true, tool interacts with external entities
	OpenWorldHint bool `json:"openWorldHint,omitempty"`
}

// NewTool creates a new Tool with the given name and options.
// The tool will have an object-type input schema with configurable properties.
// Options are applied in order, allowing for flexible tool configuration.
func NewTool(name string, opts ...ToolOption) ToolDefinition {
	tool := ToolDefinition{
		Name: name,
		InputSchema: ToolInputSchema{
			Type:       "object",
			Properties: make(map[string]interface{}),
			Required:   nil, // Will be omitted from JSON if empty
		},
		Annotations: ToolAnnotation{
			Title:           "",
			ReadOnlyHint:    false,
			DestructiveHint: true,
			IdempotentHint:  false,
			OpenWorldHint:   true,
		},
	}

	for _, opt := range opts {
		opt(&tool)
	}

	return tool
}

type ToolDefinition struct {
	Name        string         `json:"name"`
	Description string         `json:"description"`
	Parameters  map[string]any `json:"parameters"`
	// A JSON Schema object defining the expected parameters for the tool.
	InputSchema ToolInputSchema `json:"inputSchema"`
	// Alternative to InputSchema - allows arbitrary JSON Schema to be provided
	RawInputSchema json.RawMessage `json:"-"` // Hide this from JSON marshaling
	Annotations    ToolAnnotation  `json:"annotations"`
}

// ToolCallRequest represents the LLM's request to execute a specific tool.
// This structure would typically be part of an Assistant message's `ToolCalls` slice.
type ToolCall struct {
	ID           string          `json:"id"`            // Unique ID for this specific call instance (generated by LLM or orchestrator)
	FunctionName string          `json:"function_name"` // Name of the tool to call (must match a ToolDescription.Name)
	Arguments    json.RawMessage `json:"arguments"`     // Arguments for the tool, formatted as a JSON object matching the ToolDescription.InputSchema. Use json.RawMessage for flexibility.
}

type ToolDescription struct {
	Name         string          `json:"name"`
	Description  string          `json:"description"`
	InputSchema  json.RawMessage `json:"input_schema"`            // Expects JSON Schema definition here
	OutputSchema json.RawMessage `json:"output_schema,omitempty"` // Optional: Schema for the tool's result
	// Potentially SecurityMetadata for verifying the description itself
}

// ToolResultMetadata provides details about the execution of a tool.
// This is embedded within a `Message` where `Role == RoleTool`.
type ToolResultMetadata struct {
	ExecutionStatus ExecutionStatus `json:"execution_status"`        // Succeeded, Failed, Error
	ErrorMessage    string          `json:"error_message,omitempty"` // Details if status is Failed or Error
	OutputHash      string          `json:"output_hash,omitempty"`   // Cryptographic hash of the raw output content (in Message.Content)
	ExecutedAt      time.Time       `json:"executed_at"`             // Timestamp of tool execution completion
	ExecutionEnv    string          `json:"execution_env,omitempty"` // Info about the environment (e.g., "sandbox-v1", "direct-api")
	// Potential Extensions: Latency, cost, logs reference, etc.
}

type ToolCallResult struct {
	ToolResultMetadata
	Content []Content `json:"content"` // Can be TextContent, ImageContent, or EmbeddedResource
}

// ListToolsRequest requests a list of available tools.
type ListToolsRequest struct {
	PaginatedRequest
	Page    int `json:"page,omitempty"`
	PerPage int `json:"per_page,omitempty"`
}

// ListToolsResult returns a list of tools.
type ListToolsResult struct {
	Tools []ToolDefinition `json:"tools"`
	Total int              `json:"total"`
	PaginatedResult
}
