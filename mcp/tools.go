package mcp

import (
	"context"
	"encoding/json"
	"errors"
	"fmt"
	"strings"
	"time"

	"github.com/xeipuuv/gojsonschema"
)

// ToolOption is a function that configures a Tool.
// It provides a flexible way to set various properties of a Tool using the functional options pattern.
type ToolOption func(*ToolDefinition)

type ToolInputSchema struct {
	Type       string                 `json:"type"`
	Properties map[string]interface{} `json:"properties,omitempty"`
	Required   []string               `json:"required,omitempty"`
}

// Tool represents a tool definition in MCP
type Tool struct {
	Name        string          `json:"name"`
	Description string          `json:"description"`
	Schema      json.RawMessage `json:"schema"`
	Fingerprint string          `json:"fingerprint,omitempty"` // Schema fingerprint
	Checksum    string          `json:"checksum,omitempty"`    // Tool definition checksum
}

// ToolSet represents a collection of tools with security information
type ToolSet struct {
	Tools                 []Tool `json:"tools"`
	SecurityEnabled       bool   `json:"securityEnabled"`
	SchemaFingerprintAlgo string `json:"schemaFingerprintAlgo,omitempty"`
	ChecksumAlgo          string `json:"checksumAlgo,omitempty"`
}

type ToolAnnotation struct {
	// Human-readable title for the tool
	Title string `json:"title,omitempty"`
	// If true, the tool does not modify its environment
	ReadOnlyHint bool `json:"readOnlyHint,omitempty"`
	// If true, the tool may perform destructive updates
	DestructiveHint bool `json:"destructiveHint,omitempty"`
	// If true, repeated calls with same args have no additional effect
	IdempotentHint bool `json:"idempotentHint,omitempty"`
	// If true, tool interacts with external entities
	OpenWorldHint bool `json:"openWorldHint,omitempty"`
}

// NewTool creates a new Tool with the given name and options.
// The tool will have an object-type input schema with configurable properties.
// Options are applied in order, allowing for flexible tool configuration.
func NewTool(name string, opts ...ToolOption) ToolDefinition {
	tool := ToolDefinition{
		Name: name,
		InputSchema: ToolInputSchema{
			Type:       "object",
			Properties: make(map[string]interface{}),
			Required:   nil, // Will be omitted from JSON if empty
		},
		Annotations: ToolAnnotation{
			Title:           "",
			ReadOnlyHint:    false,
			DestructiveHint: true,
			IdempotentHint:  false,
			OpenWorldHint:   true,
		},
	}

	for _, opt := range opts {
		opt(&tool)
	}

	return tool
}

type ToolDefinition struct {
	Name        string         `json:"name"`
	Description string         `json:"description"`
	Parameters  map[string]any `json:"parameters"`
	// A JSON Schema object defining the expected parameters for the tool.
	InputSchema ToolInputSchema `json:"inputSchema"`
	// Alternative to InputSchema - allows arbitrary JSON Schema to be provided
	RawInputSchema json.RawMessage `json:"-"` // Hide this from JSON marshaling
	Annotations    ToolAnnotation  `json:"annotations"`
}

// ToolCallRequest represents the LLM's request to execute a specific tool.
// This structure would typically be part of an Assistant message's `ToolCalls` slice.
type ToolCall struct {
	ID           string          `json:"id"`            // Unique ID for this specific call instance (generated by LLM or orchestrator)
	FunctionName string          `json:"function_name"` // Name of the tool to call (must match a ToolDescription.Name)
	Arguments    json.RawMessage `json:"arguments"`     // Arguments for the tool, formatted as a JSON object matching the ToolDescription.InputSchema. Use json.RawMessage for flexibility.
}

type ToolDescription struct {
	Name         string          `json:"name"`
	Description  string          `json:"description"`
	InputSchema  json.RawMessage `json:"input_schema"`            // Expects JSON Schema definition here
	OutputSchema json.RawMessage `json:"output_schema,omitempty"` // Optional: Schema for the tool's result
	// Potentially SecurityMetadata for verifying the description itself
}

// ToolResultMetadata provides details about the execution of a tool.
// This is embedded within a `Message` where `Role == RoleTool`.
type ToolResultMetadata struct {
	ExecutionStatus ExecutionStatus `json:"execution_status"`        // Succeeded, Failed, Error
	ErrorMessage    string          `json:"error_message,omitempty"` // Details if status is Failed or Error
	OutputHash      string          `json:"output_hash,omitempty"`   // Cryptographic hash of the raw output content (in Message.Content)
	ExecutedAt      time.Time       `json:"executed_at"`             // Timestamp of tool execution completion
	ExecutionEnv    string          `json:"execution_env,omitempty"` // Info about the environment (e.g., "sandbox-v1", "direct-api")
	// Potential Extensions: Latency, cost, logs reference, etc.
}

type ToolCallResult struct {
	ToolResultMetadata
	Content []Content `json:"content"` // Can be TextContent, ImageContent, or EmbeddedResource
}

// FindToolDescription retrieves the trusted tool description by name.
// In a real system, this might involve looking up in a secure registry
// and potentially verifying signatures/sources stored in SecurityMetadata.
func FindToolDescription(name string, availableTools []ToolDescription) (*ToolDescription, error) {
	for _, tool := range availableTools {
		if tool.Name == name {
			// TODO: Add verification of tool description source/integrity here
			// based on tool.SecurityMetadata if available.
			return &tool, nil // Return pointer to avoid copying large schemas
		}
	}
	return nil, fmt.Errorf("tool '%s' not found or not permitted", name)
}

// ValidateToolSchema is called by the orchestrator when an LLM requests a tool call.
func ValidateToolSchema(
	ctx context.Context,
	toolCall ToolCall,
	availableTools []ToolDescription,
) (executionStatus ExecutionStatus, execErr error) {
	toolDesc, err := FindToolDescription(toolCall.FunctionName, availableTools)
	if err != nil {
		return StatusError, fmt.Errorf("tool description lookup failed: %w", err)
	}

	// Only validate if schema is provided
	if len(toolDesc.InputSchema) > 0 {
		schemaLoader := gojsonschema.NewBytesLoader(toolDesc.InputSchema)
		documentLoader := gojsonschema.NewBytesLoader(toolCall.Arguments)
		schema, err := gojsonschema.NewSchema(schemaLoader)
		if err != nil {
			return StatusError, fmt.Errorf("internal schema error for tool '%s'", toolDesc.Name)
		}

		result, err := schema.Validate(documentLoader)
		if err != nil {
			return StatusError, fmt.Errorf("internal validation error for tool '%s'", toolDesc.Name)
		}

		if !result.Valid() {
			var validationErrors []string
			for _, desc := range result.Errors() {
				validationErrors = append(validationErrors, fmt.Sprintf("- %s", desc))
			}
			errorMsg := fmt.Sprintf("Input validation failed for tool '%s':\n%s",
				toolDesc.Name, strings.Join(validationErrors, "\n"))
			fmt.Println("SECURITY ALERT:", errorMsg) // Log prominently
			return StatusFailed, errors.New(errorMsg)
		}
		fmt.Printf("Input arguments for tool '%s' validated successfully.\n", toolDesc.Name)
	} else {
		return StatusFailed, fmt.Errorf("no InputSchema defined for tool '%s'", toolDesc.Name)
	}

	return StatusSucceeded, nil
}

func ValidateToolCallOutput(
	rawResult string,
	toolCall ToolCall,
	availableTools []ToolDescription,
) (ExecutionStatus, error) {
	toolDesc, err := FindToolDescription(toolCall.FunctionName, availableTools)
	if err != nil {
		return StatusError, fmt.Errorf("tool description lookup failed: %w", err)
	}

	if len(toolDesc.OutputSchema) > 0 {
		outputSchemaLoader := gojsonschema.NewBytesLoader(toolDesc.OutputSchema)
		outputDocumentLoader := gojsonschema.NewStringLoader(rawResult)

		outputSchema, err := gojsonschema.NewSchema(outputSchemaLoader)
		if err != nil {
			// Schema itself is invalid!
			fmt.Printf("ERROR: Invalid OutputSchema for tool '%s': %v\n", toolDesc.Name, err)
			return StatusError, fmt.Errorf("internal output schema error for tool '%s'", toolDesc.Name)
		}

		outputResult, err := outputSchema.Validate(outputDocumentLoader)
		if err != nil {
			fmt.Printf("ERROR: Output validation process error for tool '%s': %v\n", toolDesc.Name, err)
			return StatusError, fmt.Errorf("internal output validation error for tool '%s'", toolDesc.Name)
		}

		if !outputResult.Valid() {
			var validationErrors []string
			for _, desc := range outputResult.Errors() {
				validationErrors = append(validationErrors, fmt.Sprintf("- %s", desc))
			}
			errorMsg := fmt.Sprintf("Tool '%s' output failed validation:\n%s\nRaw Output: %s",
				toolDesc.Name, strings.Join(validationErrors, "\n"), rawResult)
			fmt.Println("SECURITY ALERT:", errorMsg)
			return StatusFailed, errors.New(errorMsg)
		}
		fmt.Printf("Output content for tool '%s' validated successfully.\n", toolDesc.Name)
	}
	return StatusSucceeded, nil
}
